/*******************************************************************************
 jquery.mb.components
 (Updated to jQuery 3.7+ and implemented no-conflict mode, integramod.com, December 2024)
 Copyright (c) 2001-2010. Matteo Bicocchi (Pupunzi); Open lab srl, Firenze - Italy
 email: mbicocchi@open-lab.com
 site: http://pupunzi.com
 
 Licences: MIT, GPL
 http://www.opensource.org/licenses/mit-license.php
 http://www.gnu.org/licenses/gpl.html
******************************************************************************/
 
(function($) {
    $.fn.hoverIntent = function(options) {
        var cfg = {
            sensitivity: 7,
            interval: 100,
            timeout: 0
        };
 
        if (typeof options === 'object') {
            cfg = $.extend(cfg, options);
        } else if ($.isFunction(options)) {
            cfg = $.extend(cfg, {
                over: options,
                out: arguments[1] || $.noop
            });
        }
 
        var cX, cY, pX, pY;
 
        var track = function(ev) {
            cX = ev.pageX;
            cY = ev.pageY;
        };
 
        var compare = function(ev, ob) {
            ob.hoverIntent_t = clearTimeout(ob.hoverIntent_t);
            if ((Math.abs(pX - cX) + Math.abs(pY - cY)) < cfg.sensitivity) {
                $(ob).off('mousemove.hoverIntent', track);
                ob.hoverIntent_s = 1;
                return cfg.over.apply(ob, [ev]);
            } else {
                pX = cX;
                pY = cY;
                ob.hoverIntent_t = setTimeout(function() {
                    compare(ev, ob);
                }, cfg.interval);
            }
        };
 
        var delay = function(ev, ob) {
            ob.hoverIntent_t = clearTimeout(ob.hoverIntent_t);
            ob.hoverIntent_s = 0;
            return cfg.out.apply(ob, [ev]);
        };
 
        var handleHover = function(e) {
            var ev = $.extend({}, e);
            var ob = this;
 
            if (ob.hoverIntent_t) {
                ob.hoverIntent_t = clearTimeout(ob.hoverIntent_t);
            }
 
            if (e.type === 'mouseenter') {
                pX = ev.pageX;
                pY = ev.pageY;
                $(ob).on('mousemove.hoverIntent', track);
                if (ob.hoverIntent_s !== 1) {
                    ob.hoverIntent_t = setTimeout(function() {
                        compare(ev, ob);
                    }, cfg.interval);
                }
            } else {
                $(ob).off('mousemove.hoverIntent', track);
                if (ob.hoverIntent_s === 1) {
                    ob.hoverIntent_t = setTimeout(function() {
                        delay(ev, ob);
                    }, cfg.timeout);
                }
            }
        };
 
        return this.on({
            'mouseenter.hoverIntent': handleHover,
            'mouseleave.hoverIntent': handleHover
        });
    };
})(jQuery.noConflict(true));